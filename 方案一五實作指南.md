# 方案一+五實作指南：幾何約束增強 + 混合損失函數

## 概述

基於現有的羽球場交點檢測系統（commit 57847bcc），本指南將詳細說明如何實作**方案一（幾何約束增強）**與**方案五（混合損失函數）**的組合優化方案。

### 現況分析
- **當前mAP@0.5**: 60.5%
- **架構**: YOLOv8n-Pose
- **策略**: Strategy A (直接回歸，單點物件格式)
- **類別**: 3類 (T字、十字、L角交點)

## 實作方案總覽

### 方案一：幾何約束增強 (Homography Loss Integration)
- 整合單應性損失到現有keypoint損失
- 利用羽球場標準尺寸作為幾何先驗
- 強制關鍵點符合透視變換關係

### 方案五：混合損失函數設計
- 設計專門的幾何感知損失函數
- 整合對稱性、距離比例、角度約束
- 替換現有的CustomKeypointLoss

## 詳細實作步驟

### 階段一：幾何約束模組實作 (Week 1-2)

#### 1.1 創建幾何約束計算模組

```python
# 新文件: ultralytics/utils/geometry_constraints.py

import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from typing import Tuple, Optional

class BadmintonCourtGeometry:
    """羽球場標準尺寸和幾何約束"""
    
    # 羽球場標準尺寸 (米)
    COURT_LENGTH = 13.4
    COURT_WIDTH = 6.1
    SERVICE_LINE_DISTANCE = 1.98  # 從網線到發球線  
    DOUBLES_SIDELINE_DISTANCE = 0.46  # 單雙打邊線距離
    
    # 羽球場完整線條結構定義 (正規化座標，以場地中心為原點)
    # 基於標準羽球場規格，包含所有可能的交點
    
    @classmethod
    def generate_standard_court_grid(cls):
        """
        根據標準羽球場規格生成 6x5 = 30個交點矩陣
        
        矩陣佈局 (從上到下，從左到右):
        00:L-corner    01:T-junction  02:T-junction  03:T-junction  04:L-corner
        10:T-junction  11:Cross       12:Cross       13:Cross       14:T-junction  
        20:T-junction  21:T-junction  22:T-junction  23:T-junction  24:T-junction
        30:T-junction  31:T-junction  32:T-junction  33:T-junction  34:T-junction
        40:T-junction  41:Cross       42:Cross       43:Cross       44:T-junction
        50:T-junction  51:T-junction  52:T-junction  53:T-junction  54:T-junction
        """
        
        # 定義6行5列的網格
        rows = 6  # Y方向
        cols = 5  # X方向
        
        # 根據羽球場標準尺寸計算正規化座標
        # X座標: 從左邊線到右邊線 (-0.5 到 0.5)
        x_positions = [-0.5, -0.25, 0.0, 0.25, 0.5]  # 5個X位置
        
        # Y座標: 從底線到頂線 (-0.5 到 0.5) 
        y_positions = [0.5, 0.295, 0.0, -0.295, -0.5, -0.6]  # 6個Y位置
        # 注意：添加了-0.6來完成6行
        
        intersections = {}
        
        # 預定義每個位置的交點類型
        intersection_types = [
            [0, 1, 1, 1, 0],  # 第0行: L-corner, T-junction, T-junction, T-junction, L-corner
            [1, 2, 2, 2, 1],  # 第1行: T-junction, Cross, Cross, Cross, T-junction
            [1, 1, 1, 1, 1],  # 第2行: T-junction, T-junction, T-junction, T-junction, T-junction
            [1, 1, 1, 1, 1],  # 第3行: T-junction, T-junction, T-junction, T-junction, T-junction
            [1, 2, 2, 2, 1],  # 第4行: T-junction, Cross, Cross, Cross, T-junction
            [1, 1, 1, 1, 1],  # 第5行: T-junction, T-junction, T-junction, T-junction, T-junction
        ]
        
        intersection_id = 0
        for row in range(rows):
            for col in range(cols):
                x = x_positions[col]
                y = y_positions[row]
                intersection_type = intersection_types[row][col]
                
                intersections[f'point_{row}{col}'] = {
                    'coords': (x, y),
                    'type': intersection_type,
                    'id': intersection_id,
                    'grid_pos': (row, col)
                }
                intersection_id += 1
        
        return intersections
    
    @classmethod
    def generate_all_intersections(cls):
        """使用標準網格生成交點"""
        return cls.generate_standard_court_grid()
    
    @classmethod
    def get_expected_distances(cls):
        """獲取所有交點間的標準距離矩陣"""
        intersections = cls.generate_all_intersections()
        points = [info['coords'] for info in intersections.values()]
        n_points = len(points)
        
        distances = torch.zeros(n_points, n_points)
        
        for i in range(n_points):
            for j in range(i+1, n_points):
                dist = np.sqrt((points[i][0] - points[j][0])**2 + 
                              (points[i][1] - points[j][1])**2)
                distances[i, j] = distances[j, i] = dist
        
        return distances, intersections
    

class HomographyConstraint(nn.Module):
    """單應性幾何約束模組"""
    
    def __init__(self, device='cpu'):
        super().__init__()
        self.device = device
        self.court_geometry = BadmintonCourtGeometry()
        
        # 預計算標準距離矩陣和交點信息
        expected_distances, intersections_info = self.court_geometry.get_expected_distances()
        self.register_buffer('expected_distances', expected_distances)
        
        # 存儲交點信息用於分析
        self.intersections_info = intersections_info
        
        print(f"Initialized with {len(intersections_info)} standard intersection points")
        
    def forward(self, predicted_keypoints: torch.Tensor, 
                keypoint_classes: torch.Tensor,
                confidence_threshold: float = 0.5) -> torch.Tensor:
        """
        計算單應性幾何約束損失
        
        Args:
            predicted_keypoints: [B, N, 2] 預測的關鍵點座標
            keypoint_classes: [B, N] 關鍵點類別
            confidence_threshold: 置信度閾值
            
        Returns:
            homography_loss: 幾何一致性損失
        """
        batch_size = predicted_keypoints.shape[0]
        total_loss = 0.0
        valid_samples = 0
        
        for b in range(batch_size):
            # 提取該batch的有效關鍵點
            valid_mask = keypoint_classes[b] >= 0  # 假設-1表示無效點
            if valid_mask.sum() < 4:  # 至少需要4個點計算單應性
                continue
                
            valid_points = predicted_keypoints[b][valid_mask]
            valid_classes = keypoint_classes[b][valid_mask]
            
            # 計算幾何一致性損失
            geo_loss = self._compute_geometric_consistency(valid_points, valid_classes)
            total_loss += geo_loss
            valid_samples += 1
            
        return total_loss / max(valid_samples, 1)
    
    def _compute_geometric_consistency(self, points: torch.Tensor, 
                                     classes: torch.Tensor) -> torch.Tensor:
        """計算點集的幾何一致性"""
        n_points = points.shape[0]
        if n_points < 4:
            return torch.tensor(0.0, device=self.device)
        
        # 計算預測點間的距離矩陣
        pred_distances = self._compute_distance_matrix(points)
        
        # 根據類別獲取對應的期望距離
        expected_dist = self._get_expected_distances_for_classes(classes)
        
        # 計算距離比例一致性
        ratio_loss = self._compute_ratio_consistency(pred_distances, expected_dist)
        
        # 計算角度約束
        angle_loss = self._compute_angle_constraints(points, classes)
        
        return ratio_loss + 0.5 * angle_loss
    
    def _compute_distance_matrix(self, points: torch.Tensor) -> torch.Tensor:
        """計算點集的距離矩陣"""
        n_points = points.shape[0]
        distances = torch.zeros(n_points, n_points, device=self.device)
        
        for i in range(n_points):
            for j in range(i+1, n_points):
                dist = torch.norm(points[i] - points[j])
                distances[i, j] = distances[j, i] = dist
                
        return distances
    
    def _get_expected_distances_for_classes(self, classes: torch.Tensor) -> torch.Tensor:
        """根據類別獲取期望距離"""
        # 這裡需要根據實際的類別映射來實現
        # 暫時返回預設值
        n_points = len(classes)
        return torch.ones(n_points, n_points, device=self.device)
    
    def _compute_ratio_consistency(self, pred_dist: torch.Tensor, 
                                 expected_dist: torch.Tensor) -> torch.Tensor:
        """計算距離比例一致性"""
        # 避免除零
        mask = expected_dist > 1e-6
        if not mask.any():
            return torch.tensor(0.0, device=self.device)
        
        ratios_pred = pred_dist[mask] / (pred_dist[mask].mean() + 1e-6)
        ratios_expected = expected_dist[mask] / (expected_dist[mask].mean() + 1e-6)
        
        return F.smooth_l1_loss(ratios_pred, ratios_expected)
    
    def _compute_angle_constraints(self, points: torch.Tensor, 
                                 classes: torch.Tensor) -> torch.Tensor:
        """計算角度約束 (90度關係)"""
        if points.shape[0] < 3:
            return torch.tensor(0.0, device=self.device)
        
        # 尋找形成直角的點組合
        angle_loss = 0.0
        angle_count = 0
        
        for i in range(len(points)):
            for j in range(len(points)):
                for k in range(len(points)):
                    if i != j and j != k and i != k:
                        # 檢查是否應該形成直角
                        if self._should_form_right_angle(classes[i], classes[j], classes[k]):
                            angle = self._compute_angle(points[i], points[j], points[k])
                            target_angle = torch.tensor(np.pi/2, device=self.device)
                            angle_loss += (angle - target_angle).pow(2)
                            angle_count += 1
        
        return angle_loss / max(angle_count, 1)
    
    def _should_form_right_angle(self, class_i: int, class_j: int, class_k: int) -> bool:
        """判斷三個類別的點是否應該形成直角"""
        # 根據羽球場幾何結構判斷
        # 這裡需要根據具體的類別定義來實現
        return True  # 簡化版本
    
    def _compute_angle(self, p1: torch.Tensor, p2: torch.Tensor, p3: torch.Tensor) -> torch.Tensor:
        """計算三點形成的角度 (以p2為頂點)"""
        v1 = p1 - p2
        v2 = p3 - p2
        
        cos_angle = torch.dot(v1, v2) / (torch.norm(v1) * torch.norm(v2) + 1e-6)
        cos_angle = torch.clamp(cos_angle, -1.0, 1.0)
        
        return torch.acos(cos_angle)
```

#### 1.2 創建對稱性約束模組

```python
# 在 ultralytics/utils/geometry_constraints.py 中添加

class SymmetryConstraint(nn.Module):
    """對稱性約束模組 - 利用羽球場左右對稱特性"""
    
    def __init__(self, device='cpu'):
        super().__init__()
        self.device = device
        
    def forward(self, predicted_keypoints: torch.Tensor,
                keypoint_classes: torch.Tensor,
                image_center_x: float = 0.5) -> torch.Tensor:
        """
        計算對稱性約束損失
        
        Args:
            predicted_keypoints: [B, N, 2] 預測關鍵點
            keypoint_classes: [B, N] 關鍵點類別
            image_center_x: 影像中心線x座標 (正規化)
        """
        batch_size = predicted_keypoints.shape[0]
        total_loss = 0.0
        valid_pairs = 0
        
        for b in range(batch_size):
            valid_mask = keypoint_classes[b] >= 0
            if valid_mask.sum() < 2:
                continue
                
            valid_points = predicted_keypoints[b][valid_mask]
            valid_classes = keypoint_classes[b][valid_mask]
            
            # 找到對稱點對
            symmetric_pairs = self._find_symmetric_pairs(valid_points, valid_classes, image_center_x)
            
            for left_point, right_point in symmetric_pairs:
                # 檢查對稱性
                expected_right_x = 2 * image_center_x - left_point[0]
                symmetry_error = (right_point[0] - expected_right_x).pow(2)
                
                # y座標應該相同
                y_error = (right_point[1] - left_point[1]).pow(2)
                
                total_loss += symmetry_error + y_error
                valid_pairs += 1
        
        return total_loss / max(valid_pairs, 1)
    
    def _find_symmetric_pairs(self, points: torch.Tensor, classes: torch.Tensor, 
                            center_x: float) -> list:
        """找到對稱的點對"""
        pairs = []
        n_points = len(points)
        
        for i in range(n_points):
            for j in range(i+1, n_points):
                if self._are_symmetric_classes(classes[i], classes[j]):
                    left_idx, right_idx = (i, j) if points[i, 0] < center_x else (j, i)
                    pairs.append((points[left_idx], points[right_idx]))
        
        return pairs
    
    def _are_symmetric_classes(self, class1: int, class2: int) -> bool:
        """判斷兩個類別是否為對稱類別"""
        # 根據羽球場的對稱結構定義
        symmetric_pairs = [(0, 0), (1, 1), (2, 2)]  # 簡化版本
        return (class1.item(), class2.item()) in symmetric_pairs
```

#### 1.3 創建混合損失函數

```python
# 新文件: ultralytics/utils/enhanced_loss.py

import torch
import torch.nn as nn
import torch.nn.functional as F
from .geometry_constraints import HomographyConstraint, SymmetryConstraint

class EnhancedKeypointLoss(nn.Module):
    """
    增強型關鍵點損失函數 - 方案一+五的核心實現
    
    組合損失:
    1. 基礎關鍵點損失 (去除面積依賴)
    2. 幾何一致性損失 (單應性約束)
    3. 對稱性損失
    4. 距離比例損失
    5. 角度約束損失
    """
    
    def __init__(self, sigmas=None, device='cpu', 
                 w_base=1.0, w_homo=0.5, w_sym=0.3, w_ratio=0.2, w_angle=0.2):
        super().__init__()
        self.device = device
        
        # 損失權重
        self.w_base = w_base      # 基礎關鍵點損失權重
        self.w_homo = w_homo      # 單應性約束權重
        self.w_sym = w_sym        # 對稱性約束權重  
        self.w_ratio = w_ratio    # 距離比例權重
        self.w_angle = w_angle    # 角度約束權重
        
        # 基礎損失組件
        if sigmas is not None:
            self.register_buffer('sigmas', sigmas)
        else:
            # 為羽球場交點使用均勻的sigma值
            self.register_buffer('sigmas', torch.ones(3, device=device) / 3)
        
        # 幾何約束模組
        self.homography_constraint = HomographyConstraint(device)
        self.symmetry_constraint = SymmetryConstraint(device)
        
    def forward(self, pred_kpts, gt_kpts, kpt_mask, 
                pred_classes=None, gt_classes=None, **kwargs):
        """
        計算增強型關鍵點損失
        
        Args:
            pred_kpts: [N, num_kpts, 3] 預測關鍵點 (x, y, conf)
            gt_kpts: [N, num_kpts, 3] 真實關鍵點 (x, y, vis)
            kpt_mask: [N, num_kpts] 關鍵點遮罩
            pred_classes: [N, num_kpts] 預測類別 (可選)
            gt_classes: [N, num_kpts] 真實類別 (可選)
        """
        # 1. 基礎關鍵點損失 (移除面積依賴)
        base_loss = self._compute_base_keypoint_loss(pred_kpts, gt_kpts, kpt_mask)
        
        # 2. 幾何一致性損失
        homo_loss = torch.tensor(0.0, device=self.device)
        if pred_classes is not None and gt_classes is not None:
            pred_xy = pred_kpts[..., :2]
            homo_loss = self.homography_constraint(pred_xy, gt_classes)
        
        # 3. 對稱性損失
        sym_loss = torch.tensor(0.0, device=self.device)
        if pred_classes is not None and gt_classes is not None:
            pred_xy = pred_kpts[..., :2]
            sym_loss = self.symmetry_constraint(pred_xy, gt_classes)
        
        # 4. 距離比例損失
        ratio_loss = self._compute_distance_ratio_loss(pred_kpts, gt_kpts, kpt_mask)
        
        # 5. 角度約束損失
        angle_loss = self._compute_angle_constraint_loss(pred_kpts, gt_kpts, kpt_mask)
        
        # 組合總損失
        total_loss = (self.w_base * base_loss + 
                     self.w_homo * homo_loss +
                     self.w_sym * sym_loss +
                     self.w_ratio * ratio_loss +
                     self.w_angle * angle_loss)
        
        return total_loss
    
    def _compute_base_keypoint_loss(self, pred_kpts, gt_kpts, kpt_mask):
        """計算基礎關鍵點損失 (去除面積依賴)"""
        # 計算歐氏距離
        d = (pred_kpts[..., 0] - gt_kpts[..., 0]).pow(2) + \
            (pred_kpts[..., 1] - gt_kpts[..., 1]).pow(2)
        
        # 關鍵點損失因子
        kpt_loss_factor = kpt_mask.shape[1] / (torch.sum(kpt_mask != 0, dim=1) + 1e-9)
        
        # 去除面積依賴的歸一化
        e = d / ((2 * self.sigmas).pow(2) * 2)  # 移除面積項
        
        return (kpt_loss_factor.view(-1, 1) * ((1 - torch.exp(-e)) * kpt_mask)).mean()
    
    def _compute_distance_ratio_loss(self, pred_kpts, gt_kpts, kpt_mask):
        """計算距離比例損失"""
        # 簡化實現 - 確保相對距離保持一致
        batch_size = pred_kpts.shape[0]
        total_loss = 0.0
        valid_samples = 0
        
        for b in range(batch_size):
            valid_mask = kpt_mask[b] > 0
            if valid_mask.sum() < 2:
                continue
            
            pred_valid = pred_kpts[b][valid_mask, :2]
            gt_valid = gt_kpts[b][valid_mask, :2]
            
            # 計算距離比例一致性
            if len(pred_valid) >= 2:
                pred_dist = torch.pdist(pred_valid)
                gt_dist = torch.pdist(gt_valid)
                
                # 比例損失
                if len(pred_dist) > 0 and len(gt_dist) > 0:
                    ratio_loss = F.smooth_l1_loss(
                        pred_dist / (pred_dist.mean() + 1e-6),
                        gt_dist / (gt_dist.mean() + 1e-6)
                    )
                    total_loss += ratio_loss
                    valid_samples += 1
        
        return total_loss / max(valid_samples, 1)
    
    def _compute_angle_constraint_loss(self, pred_kpts, gt_kpts, kpt_mask):
        """計算角度約束損失"""
        # 簡化實現 - 檢查關鍵直角關係
        batch_size = pred_kpts.shape[0]
        total_loss = 0.0
        valid_angles = 0
        
        for b in range(batch_size):
            valid_mask = kpt_mask[b] > 0
            if valid_mask.sum() < 3:
                continue
                
            pred_valid = pred_kpts[b][valid_mask, :2]
            gt_valid = gt_kpts[b][valid_mask, :2]
            
            # 對於每三個點組合，檢查角度約束
            n_points = len(pred_valid)
            for i in range(n_points):
                for j in range(n_points):
                    for k in range(n_points):
                        if i != j and j != k and i != k:
                            # 計算角度
                            pred_angle = self._compute_angle_between_points(
                                pred_valid[i], pred_valid[j], pred_valid[k]
                            )
                            gt_angle = self._compute_angle_between_points(
                                gt_valid[i], gt_valid[j], gt_valid[k]
                            )
                            
                            angle_diff = (pred_angle - gt_angle).pow(2)
                            total_loss += angle_diff
                            valid_angles += 1
        
        return total_loss / max(valid_angles, 1)
    
    def _compute_angle_between_points(self, p1, p2, p3):
        """計算三點間的角度 (以p2為頂點)"""
        v1 = p1 - p2
        v2 = p3 - p2
        
        cos_angle = torch.dot(v1, v2) / (torch.norm(v1) * torch.norm(v2) + 1e-6)
        cos_angle = torch.clamp(cos_angle, -1.0, 1.0)
        
        return torch.acos(cos_angle)
```

### 階段二：整合到現有系統 (Week 3-4)

#### 2.1 修改現有損失函數

```python
# 修改 ultralytics/utils/loss.py
# 在文件開頭添加導入

from .enhanced_loss import EnhancedKeypointLoss

# 修改 v8CustomPoseLoss 類別
class v8CustomPoseLoss(v8PoseLoss):
    """增強版自定義姿態損失 - 整合方案一+五"""

    def __init__(self, model):
        """初始化增強版損失函數"""
        super().__init__(model)
        is_pose = self.kpt_shape == [17, 3]
        nkpt = self.kpt_shape[0]  # number of keypoints
        sigmas = torch.from_numpy(OKS_SIGMA).to(self.device) if is_pose else torch.ones(nkpt, device=self.device) / nkpt
        
        # 使用增強版關鍵點損失
        self.keypoint_loss = EnhancedKeypointLoss(
            sigmas=sigmas,
            device=self.device,
            w_base=1.0,    # 基礎損失權重
            w_homo=0.5,    # 幾何一致性權重
            w_sym=0.3,     # 對稱性權重
            w_ratio=0.2,   # 距離比例權重
            w_angle=0.2    # 角度約束權重
        )

    def calculate_keypoints_loss(self, masks, target_gt_idx, keypoints, batch_idx, 
                               stride_tensor, target_bboxes, pred_kpts):
        """
        計算增強版關鍵點損失
        
        修改原有方法以支援新的損失函數
        """
        batch_idx = batch_idx.flatten()
        batch_size = len(masks)

        # [保持原有的批處理邏輯]
        max_kpts = torch.unique(batch_idx, return_counts=True)[1].max()
        batched_keypoints = torch.zeros(
            (batch_size, max_kpts, keypoints.shape[1], keypoints.shape[2]), 
            device=keypoints.device
        )

        for i in range(batch_size):
            keypoints_i = keypoints[batch_idx == i]
            batched_keypoints[i, : keypoints_i.shape[0]] = keypoints_i

        target_gt_idx_expanded = target_gt_idx.unsqueeze(-1).unsqueeze(-1)
        selected_keypoints = batched_keypoints.gather(
            1, target_gt_idx_expanded.expand(-1, -1, keypoints.shape[1], keypoints.shape[2])
        )
        selected_keypoints[..., :2] /= stride_tensor.view(1, -1, 1, 1)

        kpts_loss = 0
        kpts_obj_loss = 0

        if masks.any():
            gt_kpt = selected_keypoints[masks]
            area = xyxy2xywh(target_bboxes[masks])[:, 2:].prod(1, keepdim=True)
            pred_kpt = pred_kpts[masks]
            kpt_mask = gt_kpt[..., 2] != 0 if gt_kpt.shape[-1] == 3 else torch.full_like(gt_kpt[..., 0], True)
            
            # 使用增強版損失函數
            kpts_loss = self.keypoint_loss(
                pred_kpt, 
                gt_kpt, 
                kpt_mask,
                # 這裡可以添加類別信息如果可用
                pred_classes=None,  # 需要從模型輸出中提取
                gt_classes=None     # 需要從標籤中提取
            )

            if pred_kpt.shape[-1] == 3:
                kpts_obj_loss = self.bce_pose(pred_kpt[..., 2], kpt_mask.float())

        return kpts_loss, kpts_obj_loss
```

#### 2.2 創建配置文件

```python
# 新文件: ultralytics/cfg/enhanced_badminton.yaml
# 增強版羽球場配置

# 模型配置
model: yolov8n-pose.pt

# 數據配置  
data: badminton_kpts.yaml

# 訓練配置
epochs: 100
batch: 16
imgsz: 640
device: 'cuda'

# 增強版損失權重配置
enhanced_loss:
  w_base: 1.0      # 基礎關鍵點損失權重
  w_homo: 0.5      # 幾何一致性損失權重
  w_sym: 0.3       # 對稱性約束權重
  w_ratio: 0.2     # 距離比例權重
  w_angle: 0.2     # 角度約束權重

# 幾何約束配置
geometry_constraints:
  enable_homography: true
  enable_symmetry: true
  confidence_threshold: 0.5
  angle_tolerance: 0.1  # 角度容忍度 (弧度)

# 訓練超參數調整
lr0: 0.01
lrf: 0.01
momentum: 0.937
weight_decay: 0.0005
warmup_epochs: 3.0

# Pose特定權重
pose: 12.0    # 增加pose損失權重
kobj: 1.0

# 數據增強（保守設置，保護幾何關係）
degrees: 5.0      # 減少旋轉角度
translate: 0.05   # 減少平移
scale: 0.1        # 減少縮放
perspective: 0.0  # 關閉透視變換，保護幾何關係
flipud: 0.0       # 關閉上下翻轉
fliplr: 0.3       # 減少左右翻轉機率
mosaic: 0.8       # 減少馬賽克增強
mixup: 0.0        # 關閉mixup
```

#### 2.3 修改訓練腳本

```python
# 修改或創建新的訓練腳本: train_enhanced.py

import torch
from ultralytics import YOLO
from ultralytics.utils import LOGGER
import yaml

def load_enhanced_config(config_path):
    """載入增強版配置"""
    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)
    return config

def setup_enhanced_training(model_path, config):
    """設置增強版訓練"""
    model = YOLO(model_path)
    
    # 設置增強版損失權重
    if hasattr(model.model, 'model') and len(model.model.model) > 0:
        # 獲取最後一層（通常是損失函數）
        last_layer = model.model.model[-1]
        if hasattr(last_layer, 'loss'):
            loss_fn = last_layer.loss
            if hasattr(loss_fn, 'keypoint_loss'):
                # 更新權重
                enhanced_config = config.get('enhanced_loss', {})
                loss_fn.keypoint_loss.w_base = enhanced_config.get('w_base', 1.0)
                loss_fn.keypoint_loss.w_homo = enhanced_config.get('w_homo', 0.5)
                loss_fn.keypoint_loss.w_sym = enhanced_config.get('w_sym', 0.3)
                loss_fn.keypoint_loss.w_ratio = enhanced_config.get('w_ratio', 0.2)
                loss_fn.keypoint_loss.w_angle = enhanced_config.get('w_angle', 0.2)
                
                LOGGER.info(f"Enhanced loss weights updated: {enhanced_config}")
    
    return model

def main():
    # 載入配置
    config = load_enhanced_config('ultralytics/cfg/enhanced_badminton.yaml')
    
    # 設置模型
    model = setup_enhanced_training(config['model'], config)
    
    # 提取訓練參數
    train_args = {k: v for k, v in config.items() 
                  if k not in ['enhanced_loss', 'geometry_constraints']}
    
    # 開始訓練
    results = model.train(**train_args)
    
    # 訓練完成後的分析
    LOGGER.info("Enhanced training completed!")
    LOGGER.info(f"Best mAP@0.5: {results.results_dict.get('metrics/mAP50(B)', 'N/A')}")
    
    return results

if __name__ == '__main__':
    main()
```

### 階段三：測試與驗證 (Week 5-6)

#### 3.1 創建驗證腳本

```python
# 新文件: validate_enhanced.py

import torch
import numpy as np
from ultralytics import YOLO
from ultralytics.utils.metrics import ConfusionMatrix
import matplotlib.pyplot as plt

class EnhancedValidator:
    """增強版驗證器"""
    
    def __init__(self, model_path, data_path):
        self.model = YOLO(model_path)
        self.data_path = data_path
        
    def validate_with_geometry_analysis(self):
        """執行幾何分析驗證"""
        results = self.model.val(data=self.data_path)
        
        # 分析幾何一致性
        geometry_metrics = self._analyze_geometry_consistency()
        
        # 分析對稱性
        symmetry_metrics = self._analyze_symmetry()
        
        # 生成報告
        self._generate_validation_report(results, geometry_metrics, symmetry_metrics)
        
        return results
    
    def _analyze_geometry_consistency(self):
        """分析幾何一致性"""
        # 實現幾何一致性分析邏輯
        return {
            'avg_ratio_error': 0.0,
            'angle_accuracy': 0.0,
            'distance_consistency': 0.0
        }
    
    def _analyze_symmetry(self):
        """分析對稱性"""
        # 實現對稱性分析邏輯
        return {
            'symmetry_error': 0.0,
            'symmetric_pairs_detected': 0
        }
    
    def _generate_validation_report(self, results, geometry_metrics, symmetry_metrics):
        """生成驗證報告"""
        print("=== Enhanced Validation Report ===")
        print(f"mAP@0.5: {results.box.map50}")
        print(f"mAP@0.5:0.95: {results.box.map}")
        print(f"Geometry consistency: {geometry_metrics}")
        print(f"Symmetry metrics: {symmetry_metrics}")

def compare_with_baseline():
    """與基線模型比較"""
    print("Comparing enhanced model with baseline...")
    
    # 載入基線模型
    baseline_model = YOLO('runs/pose/badminton_kpts9/weights/best.pt')
    baseline_results = baseline_model.val()
    
    # 載入增強模型
    enhanced_model = YOLO('runs/pose/enhanced_badminton/weights/best.pt')  
    enhanced_results = enhanced_model.val()
    
    # 比較結果
    print(f"Baseline mAP@0.5: {baseline_results.box.map50:.4f}")
    print(f"Enhanced mAP@0.5: {enhanced_results.box.map50:.4f}")
    print(f"Improvement: {enhanced_results.box.map50 - baseline_results.box.map50:.4f}")

def test_geometry_model():
    """測試幾何模型是否正確生成交點"""
    from ultralytics.utils.geometry_constraints import BadmintonCourtGeometry
    
    geometry = BadmintonCourtGeometry()
    intersections = geometry.generate_all_intersections()
    
    print(f"Generated {len(intersections)} intersection points:")
    
    # 按類型統計
    type_counts = {0: 0, 1: 0, 2: 0}  # L角, T字, 十字
    type_names = {0: 'L角', 1: 'T字', 2: '十字'}
    
    for name, info in intersections.items():
        intersection_type = info['type']
        coords = info['coords']
        type_counts[intersection_type] += 1
        print(f"{name}: {coords} -> {type_names[intersection_type]}")
    
    print(f"\n統計:")
    for type_id, count in type_counts.items():
        print(f"{type_names[type_id]}: {count}個")
    
    print(f"總計: {sum(type_counts.values())}個交點")
    
    # 檢查是否接近實際標註的數量（應該約30-50個）
    total_intersections = sum(type_counts.values())
    if 25 <= total_intersections <= 50:
        print("✅ 交點數量合理")
    else:
        print(f"⚠️  交點數量可能有誤: {total_intersections}")

if __name__ == '__main__':
    # 首先測試幾何模型
    test_geometry_model()
    
    # 然後進行驗證
    validator = EnhancedValidator(
        'runs/pose/enhanced_badminton/weights/best.pt',
        'badminton_kpts.yaml'
    )
    validator.validate_with_geometry_analysis()
    compare_with_baseline()
```

#### 3.2 超參數調優指南

```python
# 新文件: hyperparameter_tuning.py

import optuna
from ultralytics import YOLO
import tempfile
import os

def objective(trial):
    """Optuna優化目標函數"""
    
    # 採樣超參數
    w_homo = trial.suggest_float('w_homo', 0.1, 1.0)
    w_sym = trial.suggest_float('w_sym', 0.1, 0.8) 
    w_ratio = trial.suggest_float('w_ratio', 0.05, 0.5)
    w_angle = trial.suggest_float('w_angle', 0.05, 0.5)
    
    lr0 = trial.suggest_float('lr0', 0.001, 0.1, log=True)
    pose_weight = trial.suggest_float('pose_weight', 8.0, 20.0)
    
    # 創建臨時配置
    config = {
        'model': 'yolov8n-pose.pt',
        'data': 'badminton_kpts.yaml',
        'epochs': 50,  # 減少epochs以加速調優
        'batch': 16,
        'imgsz': 640,
        'lr0': lr0,
        'pose': pose_weight,
        'patience': 10,
        'enhanced_loss': {
            'w_homo': w_homo,
            'w_sym': w_sym, 
            'w_ratio': w_ratio,
            'w_angle': w_angle
        }
    }
    
    # 訓練模型
    model = YOLO('yolov8n-pose.pt')
    results = model.train(**config)
    
    # 返回驗證mAP作為優化目標
    return results.results_dict.get('metrics/mAP50(B)', 0.0)

def run_hyperparameter_optimization():
    """執行超參數優化"""
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=50)
    
    print("Best parameters:")
    print(study.best_params)
    print(f"Best mAP@0.5: {study.best_value:.4f}")
    
    return study.best_params

if __name__ == '__main__':
    best_params = run_hyperparameter_optimization()
```

## 預期效果與時程

### 效果預期
- **mAP@0.5**: 60.5% → 70-75%
- **幾何一致性**: 顯著提升
- **對稱性錯誤**: 降低40%
- **角度準確性**: 提升30%

### 實施時程
- **第1-2週**: 核心模組開發（幾何約束、混合損失）
- **第3-4週**: 系統整合與測試
- **第5-6週**: 驗證、調優與文檔

### 風險評估
- **低風險**: 基於現有架構的增量改進
- **中等複雜度**: 需要仔細調整損失權重
- **高回報**: 預期顯著的性能提升

## 後續發展方向

1. **數據增強改進**: 開發幾何感知的增強策略
2. **實時推理優化**: 減少幾何約束計算開銷
3. **多尺度適應**: 支援不同分辨率的場地檢測
4. **魯棒性提升**: 處理遮擋和光照變化

這個實作方案將為您的羽球場交點檢測系統帶來實質性的改進，同時保持良好的可維護性和擴展性。